<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktives 4x4 Bingo-Feld (Multiplayer)</title>
    <!-- Tailwind CSS wird geladen für das Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Setzt die Standardschriftart und macht den Text zentriert */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Definiert die Größe des Bingo-Feldes und die zentrierte Anzeige */
        .bingo-grid {
            max-width: 600px;
            width: 90vw; /* Responsiv: 90% der Viewport-Breite */
            aspect-ratio: 1 / 1; /* Hält das Grid quadratisch */
            gap: 8px; /* Abstand zwischen den Feldern */
        }
        /* Styling für ein einzelnes Bingo-Feld */
        .bingo-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            line-height: 1.2;
            min-height: 100%;
            user-select: none; /* Verhindert ungewolltes Markieren von Text beim Klicken */
        }
        /* Zustand 0: Unmarkiert (Editierbar) */
        .state-0 {
            background-color: #ffffff;
            color: #374151; /* Grauer Text */
            border: 2px solid #e5e7eb;
            cursor: text; /* Text-Cursor, da editierbar */
        }
        .state-0:hover {
            border-color: #9ca3af;
        }
        /* Zustand 'Spiel bereit' (Klickbar, wenn nicht markiert) */
        .cell-ready {
             cursor: pointer !important; 
        }
        /* Zustand 'Markieren blockiert' (wenn Spiel noch nicht gestartet oder nicht Spieler-Rolle) */
        .cell-locked {
            cursor: not-allowed;
            opacity: 0.8;
            pointer-events: none; /* Deaktiviert alle Klicks */
        }

        /* Die Scrollbar für editierbare Divs unsichtbar machen */
        [contenteditable]:focus {
            outline: none;
        }
        .bingo-cell::-webkit-scrollbar {
            display: none;
        }
        /* Container für temporäre Meldungen (z.B. Fehler beim Starten) */
        .message-box {
            min-height: 30px;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'player-red': '#ef4444',
                        'player-blue': '#3b82f6',
                        'success-green': '#10b981',
                        'warning-yellow': '#f59e0b',
                        'error-red': '#ef4444',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <header class="text-center mb-6">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-2">
            Multiplayer Bingo (4x4)
        </h1>
        <p class="text-gray-600 text-lg">
            Teilen Sie dieses Spiel mit einem Partner!
        </p>
    </header>
    
    <!-- Anzeige der Benutzer-ID und Rolle -->
    <div id="roleDisplay" class="mb-4 text-sm font-medium text-gray-700 p-2 bg-gray-100 rounded-lg shadow-inner w-full max-w-lg text-center">
        Verbinde zu Firebase...
    </div>

    <!-- Rollenauswahl -->
    <div id="roleSelection" class="mb-8 w-full max-w-lg p-4 rounded-xl text-center bg-white shadow-lg border border-gray-200">
        <div class="font-bold text-lg text-gray-800 mb-4">Wählen Sie Ihre Rolle/Farbe:</div>
        <div class="flex justify-center space-x-6">
            <button id="selectRed" class="px-6 py-3 font-semibold rounded-full text-white transition duration-200 shadow-xl bg-player-red hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-player-red/50">
                Spieler 1 (Rot)
            </button>
            <button id="selectBlue" class="px-6 py-3 font-semibold rounded-full text-white transition duration-200 shadow-xl bg-player-blue hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-player-blue/50">
                Spieler 2 (Blau)
            </button>
        </div>
        <p id="selectionStatus" class="mt-4 text-sm text-gray-500"></p>
    </div>

    <!-- Bingo-Grid Container -->
    <div id="bingoBoard" class="bingo-grid grid grid-cols-4">
        <!-- 16 Felder werden hier durch JavaScript hinzugefügt -->
    </div>

    <!-- Temporäre Meldungsbox -->
    <div id="messageBox" class="message-box mt-4 text-center font-semibold transition-all duration-300"></div>

    <!-- Button-Container -->
    <div class="mt-8 flex space-x-4">
        <button id="startButton" class="px-6 py-2 bg-success-green text-white font-semibold rounded-lg hover:bg-green-600 transition duration-200 shadow-md">
            Spiel starten
        </button>
        <button id="resetButton" class="hidden px-6 py-2 bg-gray-500 text-white font-semibold rounded-lg hover:bg-gray-600 transition duration-200 shadow-md">
            Board zurücksetzen
        </button>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        const BOARD_SIZE = 4;
        const board = document.getElementById('bingoBoard');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const messageBox = document.getElementById('messageBox');
        
        // Neue UI-Elemente
        const roleSelectionDiv = document.getElementById('roleSelection');
        const selectRedButton = document.getElementById('selectRed');
        const selectBlueButton = document.getElementById('selectBlue');
        const selectionStatus = document.getElementById('selectionStatus');
        
        // --- Firebase Globals ---
        // Die Firebase-Konfiguration des Benutzers wird direkt eingebunden.
        const providedFirebaseConfig = {
            apiKey: "AIzaSyCRq6xSyFutv34TEs17ERtq1U4NTz_cpBw",
            authDomain: "bingo-e2b18.firebaseapp.com",
            projectId: "bingo-e2b18",
            storageBucket: "bingo-e2b18.firebasestorage.app",
            messagingSenderId: "221274123621",
            appId: "1:221274123621:web:ccb08bb091d6d87b1e058c",
            measurementId: "G-J2W7L79MYM"
        };

        // Verwenden Sie die explizite Konfiguration
        const firebaseConfig = providedFirebaseConfig;
        
        // Verwenden Sie die Umgebungsvariable für den eindeutigen Artefaktpfad,
        // mit einem Fallback auf die projectId des Benutzers, falls nicht vorhanden.
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db = null;
        let auth = null;
        let myUserId = null;
        let myRole = 0; // 0=None/Spectator, 1=Red (Player 1), 2=Blue (Player 2)
        const GAME_DOC_PATH = `artifacts/${appId}/public/data/bingo_games/main_game`;
        
        let gameStateCache = null;

        // Initialer Spielzustand
        const initialGameState = {
            cells: Array.from({ length: BOARD_SIZE * BOARD_SIZE }, (_, i) => ({
                text: `Feld ${i + 1}`,
                state: 0, // 0: unmarked, 1: Red (Player 1), 2: Blue (Player 2)
            })),
            isGameStarted: false,
            player1Id: null,
            player2Id: null,
            lastUpdate: null, // Wird von serverTimestamp überschrieben
        };
        
        // --- UI & Utility Functions ---

        // Funktion zur Erstellung eines einzelnen Bingo-Feldes
        function createCell(index) {
            const cell = document.createElement('div');
            cell.classList.add(
                'bingo-cell',
                'state-0',
                'border',
                'cell-locked', // Startet gesperrt
                'select-none'
            );
            cell.id = `cell-${index}`;
            cell.setAttribute('contenteditable', 'true');
            cell.setAttribute('data-state', '0');
            cell.innerHTML = `Feld ${index + 1}`; 
            
            // Verwende `pointer-events: none` für die Sperrung, der Klick-Handler muss aber immer registriert sein
            cell.addEventListener('click', handleCellClick);
            
            return cell;
        }

        // Funktion zur Anzeige einer temporären Nachricht
        function showMessage(text, type = 'warning') {
            messageBox.textContent = text;
            messageBox.className = 'message-box mt-4 text-center font-semibold transition-all duration-300'; // Reset classes
            
            if (type === 'success') {
                messageBox.classList.add('text-success-green');
            } else if (type === 'warning') {
                messageBox.classList.add('text-warning-yellow');
            } else if (type === 'error') {
                 messageBox.classList.add('text-error-red');
            }
            
            // Nachricht nach 3 Sekunden ausblenden, wenn es keine Fehlermeldung ist
            if (type !== 'error') {
                 setTimeout(() => {
                    messageBox.textContent = '';
                }, 3000);
            }
        }

        // Prüft, ob alle Felder mit Text gefüllt sind
        function checkAllCellsFilled() {
            const cells = document.querySelectorAll('.bingo-cell');
            for (const cell of cells) {
                // Überprüfe den Textinhalt
                if (cell.textContent.trim() === '') {
                    return false;
                }
            }
            return true;
        }

        /**
         * Bestimmt die Rolle des Benutzers basierend auf dem aktuellen Spielzustand
         * und der eigenen Benutzer-ID.
         */
        function determineRole(gameState) {
            if (gameState.player1Id === myUserId) {
                myRole = 1; // Spieler 1 (Rot)
            } else if (gameState.player2Id === myUserId) {
                myRole = 2; // Spieler 2 (Blau)
            } else {
                myRole = 0; // Zuschauer
            }
        }


        // Aktualisiert das UI basierend auf dem globalen GameStateCache
        function updateUI(gameState) {
            gameStateCache = gameState; // Cache aktualisieren
            const cells = gameState.cells;
            
            // 1. Rollen-Display aktualisieren
            const roleDisplay = document.getElementById('roleDisplay');
            const roleText = myRole === 1 ? 'Rot (Spieler 1)' : (myRole === 2 ? 'Blau (Spieler 2)' : 'Zuschauer');
            roleDisplay.innerHTML = `Ihre ID: <span class="text-sm font-mono bg-gray-200 px-1 rounded">${myUserId}</span> | Rolle: <span class="font-bold text-${myRole === 1 ? 'player-red' : (myRole === 2 ? 'player-blue' : 'gray-700')}">${roleText}</span>`;

            // 2. Felder aktualisieren
            cells.forEach((cellData, index) => {
                const cell = document.getElementById(`cell-${index}`);
                if (!cell) return;

                // Inhalt und Zustand synchronisieren
                // Nur den Text aktualisieren, wenn das Spiel läuft, um Bearbeitungen in P1's Fenster nicht zu überschreiben
                if (gameState.isGameStarted || myRole !== 1) {
                    cell.innerHTML = cellData.text;
                }
                cell.dataset.state = cellData.state;
                
                // Klassen und Editierbarkeit zurücksetzen
                cell.classList.remove(
                    'state-0', 'bg-player-red', 'ring-player-red/70', 
                    'bg-player-blue', 'ring-player-blue/70',
                    'text-white', 'shadow-xl', 'ring-4', 'cell-ready', 'cell-locked'
                );
                cell.style.pointerEvents = 'none'; // Standardmäßig sperren

                if (gameState.isGameStarted) {
                    // Spiel läuft: Markierungsmodus
                    cell.setAttribute('contenteditable', 'false');

                    // 1. Visueller Zustand setzen
                    if (cellData.state === 1) {
                        cell.classList.add('bg-player-red', 'text-white', 'shadow-xl', 'ring-4', 'ring-player-red/70');
                    } else if (cellData.state === 2) {
                        cell.classList.add('bg-player-blue', 'text-white', 'shadow-xl', 'ring-4', 'ring-player-blue/70');
                    } else {
                        // Zustand 0: Unmarkiert
                        cell.classList.add('state-0'); 
                    }
                    
                    // 2. Interaktivität festlegen: Klickbar, wenn unmarkiert ODER eigene Farbe
                    const isInteractive = myRole > 0 && (cellData.state === 0 || cellData.state === myRole);
                    
                    if (isInteractive) {
                        cell.style.pointerEvents = 'auto'; // Klick für Markierung/Rücksetzung freigeben
                        cell.classList.add('cell-ready'); // Setzt den Klick-Cursor
                    } else {
                        cell.style.pointerEvents = 'none'; // Keine Interaktion (Gegnerfarbe oder Zuschauer)
                    }

                } else {
                    // Vorbereitungsmodus (Editierbar)
                    cell.classList.add('state-0');
                    // Nur Spieler 1 darf im Vorbereitungsmodus bearbeiten
                    cell.setAttribute('contenteditable', myRole === 1 ? 'true' : 'false');
                    // Klicks für Editieren/Start-Button-Erinnerung
                    cell.style.pointerEvents = myRole === 1 ? 'auto' : 'none'; 
                }
            });

            // 3. Button-Status aktualisieren
            const isP1 = myRole === 1;
            startButton.classList.toggle('hidden', gameState.isGameStarted || !isP1);
            resetButton.classList.toggle('hidden', !gameState.isGameStarted && !isP1); // Versteckt Reset, wenn Spiel nicht gestartet und ich nicht P1 bin

            // P1 darf den Start-Button sehen, P2/Zuschauer nicht
            if (!gameState.isGameStarted) {
                if (isP1) {
                    startButton.textContent = 'Spiel starten';
                    startButton.classList.add('bg-success-green', 'hover:bg-green-600');
                    startButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    startButton.style.pointerEvents = 'auto';
                } else {
                    // P2 oder Zuschauer
                    startButton.textContent = 'Warte auf Spieler 1...';
                    startButton.classList.remove('bg-success-green', 'hover:bg-green-600');
                    startButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                    startButton.style.pointerEvents = 'none';
                }
            }
            
            // 4. Rollenauswahl-Status aktualisieren
            const p1Occupied = gameState.player1Id !== null;
            const p2Occupied = gameState.player2Id !== null;

            roleSelectionDiv.classList.toggle('hidden', gameState.isGameStarted);
            
            if (!gameState.isGameStarted) {
                selectRedButton.disabled = p1Occupied && gameState.player1Id !== myUserId;
                selectBlueButton.disabled = p2Occupied && gameState.player2Id !== myUserId;
                
                // Update button appearance
                selectRedButton.classList.toggle('opacity-50', selectRedButton.disabled);
                selectBlueButton.classList.toggle('opacity-50', selectBlueButton.disabled);
                
                if (myRole === 1) {
                     selectionStatus.textContent = 'Sie sind Spieler 1 (Rot). Starten Sie das Spiel, wenn Sie bereit sind.';
                } else if (myRole === 2) {
                     selectionStatus.textContent = 'Sie sind Spieler 2 (Blau). Warten Sie auf den Start durch Spieler 1.';
                } else {
                     let statusText = 'Wählen Sie eine verfügbare Rolle.';
                     if (p1Occupied && p2Occupied) {
                        statusText = 'Beide Spielerrollen sind belegt. Sie sind Zuschauer.';
                     }
                     selectionStatus.textContent = statusText;
                }
            }
        }

        // --- Firebase Interaction Functions ---

        /**
         * Beantragt die gewünschte Rolle in Firestore (Spieler 1 oder 2).
         */
        async function handleRoleSelection(role) {
            if (!db || !myUserId) return showMessage('Verbindung wird hergestellt...', 'warning');

            const gameDocRef = doc(db, GAME_DOC_PATH);
            const playerKey = role === 1 ? 'player1Id' : 'player2Id';
            const opponentKey = role === 1 ? 'player2Id' : 'player1Id';
            const roleName = role === 1 ? 'Rot' : 'Blau';
            
            try {
                await runTransaction(db, async (transaction) => {
                    const docSnap = await transaction.get(gameDocRef);
                    const currentData = docSnap.data();
                    
                    // 1. Prüfe, ob die Rolle bereits belegt ist (von jemand anderem)
                    if (currentData[playerKey] && currentData[playerKey] !== myUserId) {
                        throw new Error(`Spieler ${role} (${roleName}) ist bereits belegt.`);
                    }
                    
                    // 2. Prüfe, ob ich bereits die andere Rolle habe und diese freigeben muss
                    if (currentData[opponentKey] === myUserId) {
                        transaction.update(gameDocRef, { [opponentKey]: null });
                    }

                    // 3. Rolle beanspruchen
                    transaction.update(gameDocRef, { 
                        [playerKey]: myUserId,
                        lastUpdate: serverTimestamp() 
                    });
                });
                showMessage(`Rolle als Spieler ${role} (${roleName}) erfolgreich gewählt!`, 'success');
            } catch (e) {
                console.error("Rollen-Auswahl fehlgeschlagen:", e);
                // Zeige dem Benutzer eine spezifische Fehlermeldung
                showMessage(e.message || `Rolle ${roleName} ist belegt oder Transaktion fehlgeschlagen.`, 'error');
            }
        }

        function listenToGame() {
            const gameDocRef = doc(db, GAME_DOC_PATH);

            onSnapshot(gameDocRef, async (docSnap) => {
                let gameState;
                
                if (docSnap.exists()) {
                    gameState = docSnap.data();
                    
                    // Bestimme meine Rolle nur basierend auf den aktuellen Daten
                    determineRole(gameState);

                } else {
                    // Dokument existiert nicht, erstelle es (der Ersteller wird Player 1, kann aber wechseln)
                    console.log("Game document does not exist. Creating new game.");
                    await setDoc(gameDocRef, { 
                        ...initialGameState, 
                        player1Id: myUserId, // Auto-zuweisung bei Erstellung
                        lastUpdate: serverTimestamp(),
                    });
                    return; // onSnapshot wird mit den neuen Daten erneut ausgelöst
                }

                // UI mit dem neuen Status aktualisieren
                updateUI(gameState);
            }, (error) => {
                console.error("Firestore listen error:", error);
                showMessage('Fehler beim Laden des Spielstatus.', 'error');
            });
        }
        
        // --- Game Logic ---

        // Funktion zum Starten des Spiels (Button-Klick)
        async function handleStartGame() {
            if (myRole !== 1) {
                showMessage('Nur Spieler 1 (Rot) kann das Spiel starten.', 'warning');
                return;
            }

            if (!checkAllCellsFilled()) {
                showMessage('Bitte füllen Sie zuerst alle 16 Felder mit Text aus!', 'warning');
                return;
            }
            
            const gameDocRef = doc(db, GAME_DOC_PATH);
            
            try {
                // Die endgültigen Texte aus dem DOM in den Zustand übernehmen
                const cells = Array.from(document.querySelectorAll('.bingo-cell')).map(cell => ({
                    text: cell.textContent.trim(),
                    state: 0,
                }));

                await updateDoc(gameDocRef, {
                    cells: cells,
                    isGameStarted: true,
                    lastUpdate: serverTimestamp(),
                });
                
                showMessage('Das Spiel hat begonnen! Markierungen freigegeben.', 'success');

            } catch (e) {
                console.error("Fehler beim Starten des Spiels:", e);
                showMessage('Fehler: Spiel konnte nicht gestartet werden.', 'error');
            }
        }
        
        // Funktion zum Zurücksetzen des Spiels
        async function handleResetGame() {
             if (myRole !== 1) {
                showMessage('Nur Spieler 1 (Rot) kann das Board zurücksetzen.', 'warning');
                return;
            }
            
            const gameDocRef = doc(db, GAME_DOC_PATH);
            
            // Führe das Zurücksetzen in einer Transaktion durch, um die Rollen zu erhalten
            try {
                 await runTransaction(db, async (transaction) => {
                    const docSnap = await transaction.get(gameDocRef);
                    if (!docSnap.exists()) throw new Error("Doc not found");

                    const currentData = docSnap.data();
                    
                    transaction.set(gameDocRef, {
                        ...initialGameState,
                        player1Id: currentData.player1Id, // Behalte Rollen
                        player2Id: currentData.player2Id, // Behalte Rollen
                        lastUpdate: serverTimestamp(),
                    });
                });
                showMessage('Board zurückgesetzt. Neue Begriffe können eingegeben werden.', 'success');
            } catch (e) {
                 console.error("Fehler beim Zurücksetzen:", e);
                 showMessage('Fehler: Board konnte nicht zurückgesetzt werden.', 'error');
            }
        }


        // Funktion, die den Zustand des Feldes umschaltet und die Farbe ändert (Multiplayer-Logik)
        async function handleCellClick(event) {
            if (!gameStateCache || !gameStateCache.isGameStarted) {
                showMessage('Das Spiel ist noch nicht gestartet.', 'warning');
                return;
            }

            if (myRole === 0) {
                showMessage('Sie sind Zuschauer und können nicht markieren.', 'warning');
                return;
            }

            const cell = event.currentTarget;
            const cellIndex = parseInt(cell.id.split('-')[1]);
            
            const gameDocRef = doc(db, GAME_DOC_PATH);

            try {
                // Transaktion, um Race Conditions zu vermeiden
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw "Dokument existiert nicht!";
                    }
                    let data = gameDoc.data();
                    let cells = data.cells;
                    let cellData = cells[cellIndex];
                    let currentState = cellData.state;

                    let newCellState = currentState;

                    if (currentState === 0) {
                        // Von Unmarkiert auf die eigene Farbe setzen
                        newCellState = myRole; 
                    } else if (currentState === myRole) {
                        // Von der eigenen Farbe zurück auf Unmarkiert setzen (Rückgängig)
                        newCellState = 0;
                        showMessage('Markierung zurückgesetzt.', 'success');
                    } else {
                        // Versucht, die Farbe des Gegners zu überschreiben
                        showMessage(`Feld ist bereits von Spieler ${3 - myRole} markiert!`, 'warning');
                        return; // Transaktion abbrechen
                    }

                    // Nur fortfahren, wenn sich der Zustand geändert hat
                    if (newCellState !== currentState) {
                        cellData.state = newCellState;
                        cells[cellIndex] = cellData;

                        // Commit transaction
                        transaction.update(gameDocRef, { 
                            cells: cells,
                            lastUpdate: serverTimestamp(),
                        });
                    }
                });
            } catch (e) {
                console.error("Transaktion fehlgeschlagen:", e);
                // Die onSnapshot-Funktion wird die lokale UI wieder mit den korrekten Daten synchronisieren.
            }
        }
        
        // --- Initialization ---

        // Initialisiert das gesamte Board (DOM-Struktur) und hängt Event Listener an
        function initDOM() {
            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                board.appendChild(createCell(i));
            }
            
            // Event Listener zu Buttons hinzufügen
            startButton.addEventListener('click', handleStartGame);
            resetButton.addEventListener('click', handleResetGame);
            
            // Neue Event Listener für Rollenwahl
            selectRedButton.addEventListener('click', () => handleRoleSelection(1));
            selectBlueButton.addEventListener('click', () => handleRoleSelection(2));
        }

        async function initFirebase() {
            //setLogLevel('debug'); // Wichtig für Debugging
            if (!firebaseConfig) {
                showMessage('Fehler: Firebase-Konfiguration fehlt.', 'error');
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            // Authentifizierung
            try {
                // Wir verwenden weiterhin das Canvas-Initialisierungstoken für die Authentifizierung,
                // da es für die Canvas-Umgebung erforderlich ist.
                if (initialAuthToken) {
                    const userCredential = await signInWithCustomToken(auth, initialAuthToken);
                    myUserId = userCredential.user.uid;
                } else {
                    const userCredential = await signInAnonymously(auth);
                    myUserId = userCredential.user.uid;
                }
            } catch (error) {
                console.error("Firebase Auth failed:", error);
                // Notfall: Falls Auth fehlschlägt, verwende eine zufällige ID
                myUserId = crypto.randomUUID(); 
            }
            
            // Starte DOM und Firestore Listener
            initDOM();
            listenToGame();
        }

        window.onload = initFirebase;

    </script>
</body>
</html>
